---
title: 08 - Модификаторы инкапсуляции и доступа
description: Узнайте, как защитить и контролировать доступ к данным вашего класса.
---

Инкапсуляция заключается в скрытии внутренних деталей реализации класса и контроле над тем, как происходит доступ к его данным и их модификация. Это предотвращает появление багов и делает код более поддерживаемым.

## Проблема отсутствия инкапсуляции

```java
public class Player {
    public String name;
    public int health;
    public int maxHealth;
}

public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        player.health = 100;
        player.maxHealth = 100;
        
        // Ой! Кто-то может нарушить правила
        player.health = 500;      // Значение здоровья выше максимума!
        player.health = -50;      // Отрицательное значение здоровья!
        player.name = "";         // Отсутствует значение имени!
    }
}
```

Без защиты любой внешний код может установить недопустимые значения, что нарушает логику программы.

## Модификаторы доступа

В Java существуют ключевые слова для управления доступом к членам класса:

| Модификатор | Класс | Пакет | Подкласс | Мир |
| ----------- | ----- | ----- | -------- | --- |
| `public`    | ✓     | ✓     | ✓        | ✓   |
| `protected` | ✓     | ✓     | ✓        | ✗   |
| (none)      | ✓     | ✓     | ✗        | ✗   |
| `private`   | ✓     | ✗     | ✗        | ✗   |

**На данном этапе важно сосредоточиться на двух:**

* `public` - Доступ открыт для всех
* `private` - Доступ есть только у этого класса

## Создание приватных свойств

```java
public class Player {
    private String name;
    private int health;
    private int maxHealth;
    
    public Player(String name, int maxHealth) {
        this.name = name;
        this.health = maxHealth;
        this.maxHealth = maxHealth;
    }
}
```

Теперь нельзя получить доступ к свойствам напрямую:

```java
Player player = new Player("Alice", 100);
player.health = 500;  // ❌ Ошибка! Значение health является private
```

## Геттеры и Сеттеры

Чтобы работать с `private` свойствами, необходимо создать методы доступа — **геттеры** (для чтения) и **сеттеры** (для записи):

```java
public class Player {
    private String name;
    private int health;
    private int maxHealth;
    
    public Player(String name, int maxHealth) {
        this.name = name;
        this.health = maxHealth;
        this.maxHealth = maxHealth;
    }
    
    // Геттер - возвращает значение
    public int getHealth() {
        return health;
    }
    
    // Сеттер — устанавливает значение с проверкой
    public void setHealth(int health) {
        if (health < 0) {
            this.health = 0; // Логика: здоровье не может быть меньше 0
        } else if (health > maxHealth) {
            this.health = maxHealth; // Логика: здоровье не может превышать максимум
        } else {
            this.health = health;
        }
    }
    
    public String getName() {
        return name;
    }
    
    public int getMaxHealth() {
        return maxHealth;
    }
}
```

Теперь можно безопасно взаимодействовать с этим объектом:

```java
Player player = new Player("Alice", 100);

player.setHealth(150);  // Автоматически ограничено на 100
System.out.println(player.getHealth());  // 100

player.setHealth(-20);  // Автоматически установлено на 0
System.out.println(player.getHealth());  // 0
```

<Callout type="info" title="Именование геттеров и сеттеров">
  В Java приняты следующие стандарты:

  * **Геттер**: `get` + имя свойства с большой буквы (например, `getHealth`).
  * **Сеттер**: `set` + имя свойства с большой буквы (например, setName).
  * **Boolean**: `is` + имя свойства с большой буквы (например, `isAlive`).

  ```java
  private int health;
  public int getHealth() { }
  public void setHealth(int health) { }

  private boolean alive;
  public boolean isAlive() { }
  public void setAlive(boolean alive) { }

  private String name;
  public String getName() { }
  public void setName(String name) { }
  ```
</Callout>

## Преимущества инкапсуляции

### 1. Валидация

```java
public class Item {
    private int durability;
    private int maxDurability;
    
    public void setDurability(int durability) {
        if (durability < 0) {
            this.durability = 0;
        } else if (durability > maxDurability) {
            this.durability = maxDurability;
        } else {
            this.durability = durability;
        }
    }
    
    public boolean isBroken() {
        return durability <= 0;
    }
}
```

### 2. Свойства только для чтения

Иногда вам не нужен сеттер:

```java
public class Monster {
    private String id;  // Не должен меняться
    private int health;
    
    public Monster(String id, int health) {
        this.id = id;
        this.health = health;
    }
    
    // Только геттер - не сеттер!
    public String getId() {
        return id;
    }
    
    public int getHealth() {
        return health;
    }
    
    public void setHealth(int health) {
        this.health = health;
    }
}
```

### 3. Вычисляемые свойства

Геттерам не обязательно возвращать поле напрямую:

```java
public class Player {
    private int health;
    private int maxHealth;
    
    public int getHealth() {
        return health;
    }
    
    // Вычисляемое свойство
    public double getHealthPercentage() {
        return (health * 100. ) / maxHealth;
    }
    
    // Вычисляемое свойство
    public boolean isLowHealth() {
        return getHealthPercentage() < 25;
    }
}
```

## Практические примеры

### Предмет с прочностью

```java
public class Tool {
    private String name;
    private int durability;
    private int maxDurability;
    private boolean broken;
    
    public Tool(String name, int maxDurability) {
        this.name = name;
        this.durability = maxDurability;
        this.maxDurability = maxDurability;
        this.broken = false;
    }
    
    public void use() {
        if (broken) {
            System.out.println(name + " сломана!");
            return;
        }
        
        durability--;
        System.out.println(name + " used. Durability: " + durability);
        
        if (durability <= 0) {
            broken = true;
            System.out.println(name + " сломалась!");
        }
    }
    
    public void repair() {
        durability = maxDurability;
        broken = false;
        System.out.println(name + " починена!");
    }
    
    // Геттеры
    public String getName() {
        return name;
    }
    
    public int getDurability() {
        return durability;
    }
    
    public boolean isBroken() {
        return broken;
    }
    
    public double getDurabilityPercentage() {
        return (durability * 100.0) / maxDurability;
    }
}
```

### Пример банковского счета

```java
public class PlayerWallet {
    private int gold;
    private int silver;
    
    public PlayerWallet() {
        this.gold = 0;
        this.silver = 0;
    }
    
    public void addGold(int amount) {
        if (amount > 0) {
            gold += amount;
            System.out.println("Добавлено " + amount + " золота");
        }
    }
    
    public boolean spendGold(int amount) {
        if (amount > gold) {
            System.out.println("Золота не хватает!");
            return false;
        }
        
        gold -= amount;
        System.out.println("Потрачено " + amount + " золота");
        return true;
    }
    
    public int getGold() {
        return gold;
    }
    
    public int getTotalValue() {
        // 1 золото = 100 серебра
        return gold * 100 + silver;
    }
}
```

### Защищенная блочная система

```java
public class ProtectedBlock {
    private int x, y, z;
    private String type;
    private String owner;
    private boolean locked;
    
    public ProtectedBlock(int x, int y, int z, String type, String owner) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.type = type;
        this.owner = owner;
        this.locked = true;
    }
    
    public boolean canBreak(String playerName) {
        if (!locked) {
            return true;
        }
        
        return playerName.equals(owner);
    }
    
    public void unlock(String playerName) {
        if (playerName.equals(owner)) {
            locked = false;
            System.out.println("Блок доступен");
        } else {
            System.out.println("Это не ваш блок!");
        }
    }
    
    // Только геттеры - потому что позиция и владельцы не должны меняться
    public int getX() {
        return x;
    }
    
    public int getY() {
        return y;
    }
    
    public int getZ() {
        return z;
    }
    
    public String getOwner() {
        return owner;
    }
    
    public boolean isLocked() {
        return locked;
    }
}
```

## Когда использовать Private, а когда Public

<Callout type="info" title="Общие Правила">
  **Делайте его приватным по умолчанию!** Делайте его публичным только в том случае, если необходимо иметь доступ извне.

  **Private:**

  * Внутренние данные (здоровье, расположение, инвентарь)
  * Вспомогательные методы, используемые только внутри класса
  * Все, что требует проверки

  **Public:**

  * Методы, определяющие поведение класса
  * Конструктор
  * Методы других классов должны быть вызваны

  ```java
  public class Example {
      // Private - внутренние данные
      private int internalCounter;
      private String secretKey;
      
      // Public - часть интерфейса
      public void doSomething() {
          // Использует частный вспомогательный метод
          validateData();
      }
      
      // Private- внутренний помощник
      private void validateData() {
          // . .
      }
  }
  ```
</Callout>

## Ключевое слово `final`

`final` означает, что переменная не может быть изменена после ее установки:

```java
public class Player {
    private final String id;  // Не может быть изменено после создания
    private String name;      // Может быть изменено
    private int health;       // Может быть изменено
    
    public Player(String id, String name) {
        this.id = id;
        this.name = name;
    }
    
    public String getId() {
        return id;
    }
    
    // Нет setId() — это final!
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
```

## The `static` Keyword

### Static Members

A class can define two kinds of members:

* **Instance members** — owned by each object (each instance has its own copy).

* **Static members** — owned by the class (one shared copy for the entire type).

Put simply: instance members belong to objects; static members belong to the class itself and are shared by all objects of that type.

#### Declaration

```java
    /* (access modifier) */ static ... memberName; 
```

#### Example

```java
class Data {
    public int x; // Instanced member
    public static int y = 1000; // Static member

    // Instanced member:
    // can access to both static and non-static members
    public void foo() {
        x = 100; // OK - same as this.x = 100;
        y = 100; // OK - same as Data.y = 200;
    }

    // Static member:
    // cannot access to non-static variables
    public static void bar() {
        x = 100; // Error: non-static variable x cannot be renference from a static context
        y = 100; // OK
    }
}
```

#### Accessing static members

```java
Data data = new Data();
data.x = 1000; // OK

data.y = 1000; // OK-ish - not really suggested; it's better to use Data.y
Data.y = 1000; // OK - best practice

Data.x = 1000; // Error: cannot access instanced variables in a static context
```

### Static Fields

A static field represents a data member owned by the class type rather then the object. Static fields are also stored in a specific memory location that's been shared between all the object instances that are created.

It is declared as following:

```java
/* (access modifier) (optional) */ static /* final/volatile (optional) */ fieldName;
```

Let's take the same Data class example and add this constructor:

```java
public Data() {
    y++; // remember that's the same as Data.y++;
}
```

```java
// Every instance of Data will have a private copy of the instanced member x
// However it will point to the same location in memory for the member y
Data d1 = new Data(); // y = 1001
d1.x = 5;
Data d2 = new Data(); // y = 1002
d2.x = 25;
Data d3 = new Data(); // y = 1003
// ... and so on
```

### Static Methods

Static methods essentially represent a function member of a certain class type

From the Data class remember the function (instanced method) `foo` and (static method) `bar`

One can access those methods via:

```java
Data d1 = new Data();

d1.foo(); // Instanced method: Accessible ONLY by an object

Data.bar(); // Static method: accessible without an object
```

### Static Initializer

Use a *static initializer* block to run initialization logic when the class is first loaded:

```java
class OtherData {
    private static int a = 12;
    private static int b;
    private static String msg;

    static {
        msg = "Initialization..."
        System.out.println(msg);
        b = 4;
        // ... complex initialization that can't be done in a single expression
    }
}
```

## Практические задания

1. \*\*Создайте класс `BankAccount` \*\*:
   * Private свойства: accountNumber, balance
   * Конструктор для задания номера счета
   * Методы: deposit(), withdraw(), getBalance()
   * Валидация: нельзя снять больше, чем баланс
   * Номер счета должен быть доступен только для чтения

2. **Создайте класс `Door`**
   * Private свойства: isLocked, keyCode
   * Конструктор для установки кода - ключа
   * Методы: lock(), unlock(String code), isLocked()
   * unlock() работает только с правильным кодом
   * Код должен быть private (не открывайте его!)

3. **Создайте класс `PlayerStats`**:
   * Private свойства: strength, defense, speed
   * Конструктор для установки всей статистики
   * Геттеры для всей статистики
   * Метод: getPowerLevel(), который возвращает силу + защиту + скорость
   * Статистика не может быть отрицательной или больше 100

4. **Рефакторинг класса**: возьмите один из ваших классов с предыдущего урока и добавьте правильную инкапсуляцию:
   * Сделайте все свойства private
   * Добавьте соответствующие геттеры и сеттеры
   * Добавьте валидацию там, где это необходимо
