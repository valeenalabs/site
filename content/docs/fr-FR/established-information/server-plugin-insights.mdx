---
title: Informations sur le code du serveur
description: Slikey a partagé quelques informations sur le code du serveur le 15/12/2025. Ce document couvre des points clés de cette discussion.
---

<Callout type="info" title="Note">
  Les informations qui suivent sont basées sur ce qui a été partagé par le directeur technique Slikey le 15 décembre 2025 sur le serveur discord d'Hytale. Cela offre un aperçu de l'architecture du code du serveur et des fonctionnalités de plugins.

  La majorité de ce document est juste des citations de Slikey avec des commentaires minimaux. Il s'agit plus de préserver les informations partagées que de les reformuler.
</Callout>

# Code source du serveur

Le serveur sera publié comme source partagée - nous pourrons avoir le code source sans obfuscation et tous leurs commentaires

### Licence

La licence permet l'usage pour tout ce qui est relatif à Hytale, donc tant que vous n'utilisez pas le code source pour faire votre propre jeu ou vendre leurs algorithmes.

# Système de permission

Après avoir été demandé dans le serveur d'Hytale Modding, le Lead Architecte Zero a répondu :

Il est assez simple, donc ne vous attendez pas à grand-chose mais oui nous avons un système de permissions intégré. Il supporte également l'implémentation de votre propre backend. Par exemple si vous voulez le stocker dans une base de données.

![Extrait des sources du système de permission](/assets/premission-system.png)

# Implémentation de la génération de monde

Le texte qui suit provient directement du Lead Architecte Zero :

Vous pouvez totalement implémenter une génération de monde personnalisée dans un plugin très facilement. Donc, si vous voulez une configuration ou une logique totalement différente pour la génération du terrain, vous pouvez ajouter cela dans un plugin et ensuite configurer un monde pour l'utiliser. Nous avons des choses qui chargent les préfabriqués et il y a du code existant dans les générateurs de monde actuels qui pourrait peut-être être réutilisé, mais pas d'APIs spécifiquement pour les détails de la génération elle-même.

```java
public interface IWorldGenProvider {
    BuilderCodecMapCodec<IWorldGenProvider> CODEC = new BuilderCodecMapCodec<>("Type", true);

    IWorldGen getGenerator() throws WorldGenLoadException;
}
```

```java
public interface IWorldGen {
    @Nullable
    WorldGenTimingsCollector getTimings();

    CompletableFuture<GeneratedChunk> generate(int seed, long index, int x, int z, LongPredicate stillNeeded);

    @Deprecated
    Transform[] getSpawnPoints(int seed);

    @Nonnull
    default ISpawnProvider getDefaultSpawnProvider(int seed) {
        return new FitToHeightMapSpawnProvider(new IndividualSpawnProvider(getSpawnPoints(seed)));
    }

    default void shutdown() {}
}
```

# Extraits de code du serveur

Des extraits de code d'un plugin qu'ils ont fait ont également été partagés. Les extraits suivants sont des citations directes du directeur technique Slikey :

## Plugin BlockSpawner

Très bien, je vais partager quelques extraits de code ici pour un plugin simple appelé "BlockSpawner" qui se transformera en un bloc "aléatoire" lorsqu'il sera posé dans le monde, en fonction des règles configurées.

Il y a plus de code ici en général, mais cela montre le système d'assets et la disposition du plugin. Vous pouvez voir que le système d'assets définit des "Codecs" qui sont utilisés pour sérialiser et désérialiser des données En utilisant ces codecs, nous pouvons générer des schémas.
Admettons que vous vous connectez à un serveur et ouvrez l'éditeur d'assets : le serveur vous enverra ces schémas - donc chaque type d'asset défini côté-serveur, même les vôtres, fait maintenant partie de l'éditeur d'assets sur le client - pas besoin de faire quoi que ce soit, vous pouvez juste profiter de l'interface utilisateur de l'éditeur pour faire les assets que vous avez définis

![Code de BlockSpawner 1](/assets/blockspawner-code-1.png)
![Code de BlockSpawner 2](/assets/blockspawner-code-2.png)
![Code de BlockSpawner 3](/assets/blockspawner-code-3.png)
![Manifest de BlockSpawner](/assets/blockspawner-manifest.png)

> J'imagine que cette partie montre également un peu comment nous utilisons les constantes pour stocker certaines clés de langage - Slikey
> (en référence à l'image en dessous)

![Constantes pour stocker les clés de langage](/assets/constants.png)

> Vous pouvez complètement personnaliser le fournisseur de stockage de chunks, nous en avons par exemple fait un qui est juste vide et qui ne charge aucun chunks du disque.
> Vous pourriez ajouter un MySQLChunkStorageProvider et il pourrait lire les données d'une base de données.
> Et la même chose vaut pour la génération de monde, vous pouvez simplement implémenter cette interface pour générer un générateur de monde - Slikey

![Chunks 1](/assets/chunks-1.png)
![Chunks 2](/assets/chunks-2.png)
![Chunks 3](/assets/chunks-3.png)

> Voici ici toutes les armes définies, vous me direz, évidemment vous allez découvrir des limites, mais je pense qu'il y a suffisamment de marge de progression - c'est quelque chose de difficile, il y a beaucoup d'amélioration à faire en termes de QoL (qualité de vie).

![Armes 1](/assets/weapons-1.png)
